#include "Heap.h"
#include <iostream>
#include <iomanip>
// Функция print() для вывода значения элемента AAA.
void AAA::print()
{
	std::cout << x; // Вывод значения x элемента AAA.
}

namespace heap
{
	// Функция create() для создания кучи с заданным максимальным размером и функцией сравнения.
	Heap create(int maxsize, CMP(*f)(void*, void*))
	{
		return *(new Heap(maxsize, f)); // Возвращает новую кучу с заданными параметрами.
	}

	// Функция left() для вычисления индекса левого потомка элемента в куче.
	int Heap::left(int ix)
	{
		return (2 * ix + 1 >= size) ? -1 : (2 * ix + 1); // Возвращает индекс левого потомка.
	}

	// Функция right() для вычисления индекса правого потомка элемента в куче.
	int Heap::right(int ix)
	{
		return (2 * ix + 2 >= size) ? -1 : (2 * ix + 2); // Возвращает индекс правого потомка.
	}

	// Функция parent() для вычисления индекса родительского элемента в куче.
	int Heap::parent(int ix)
	{
		return (ix + 1) / 2 - 1; // Возвращает индекс родительского элемента.
	}

	// Функция swap() для обмена элементов в куче.
	void Heap::swap(int i, int j)
	{
		void* buf = storage[i]; // Временная переменная для хранения элемента.
		storage[i] = storage[j]; // Замена элемента на позиции i элементом на позиции j.
		storage[j] = buf; // Обновление элемента на позиции j из временной переменной.
	}

	// Функция heapify() для преобразования поддерева с корнем в узле ix в кучу.
	void Heap::heapify(int ix)
	{
		int l = left(ix), r = right(ix), irl = ix; // Вычисление индексов левого и правого потомков.
		if (l > 0) // Проверка, существует ли левый потомок.
		{
			if (isGreat(storage[l], storage[ix])) irl = l; // Если левый потомок больше текущего узла, обновляем индекс максимума.
			if (r > 0 && isGreat(storage[r], storage[irl])) irl = r; // Если правый потомок больше текущего максимума, обновляем индекс максимума.
			if (irl != ix) // Если индекс максимума отличается от текущего индекса, выполняем обмен элементов и рекурсивно вызываем heapify().
			{
				swap(ix, irl); // Обмен текущего узла с узлом максимума.
				heapify(irl); // Вызов heapify для обновленного узла максимума.
			}
		}
	}


	// Функция insert() для вставки нового элемента в кучу.
	void Heap::insert(void* x)
	{
		int i;
		if (!isFull()) // Проверка на заполненность кучи.
		{
			storage[i = size++] = x; // Вставка нового элемента в кучу и увеличение размера кучи.
			while (i > 0 && isLess(storage[parent(i)], storage[i])) // Поддержание свойства кучи после вставки нового элемента.
			{
				swap(parent(i), i); // Обмен элементов, если свойство кучи нарушено.
				i = parent(i); // Переход к родительскому узлу.
			}
		}
	}

	// Функция extractMax() для извлечения максимального элемента из кучи.
	void* Heap::extractMax()
	{
		void* rc = nullptr; // Инициализация возвращаемого значения.
		if (!isEmpty()) // Проверка на пустоту кучи.
		{
			rc = storage[0]; // Сохранение максимального элемента.
			storage[0] = storage[size - 1]; // Перемещение последнего элемента в корень кучи.
			size--; // Уменьшение размера кучи.
			heapify(0); // Поддержание свойства кучи.
		}
		return rc; // Возвращение извлеченного максимального элемента.
	}

	// Функция scan() для вывода значений элементов кучи на экран.
	void Heap::scan(int i) const
	{
		int probel = 20; // Начальное значение для форматирования вывода.
		std::cout << '\n'; // Переход на новую строку.
		if (size == 0)
			std::cout << "Куча пустая"; // Вывод сообщения о пустой куче.
		for (int u = 0, y = 0; u < size; u++)
		{
			std::cout << std::setw(probel + 10) << std::setfill(' '); // Форматированный вывод значений элементов.
			((AAA*)storage[u])->print(); // Вызов функции печати элемента AAA.
			if (u == y)
			{
				std::cout << '\n'; // Переход на новую строку.
				if (y == 0)
					y = 2;
				else
					y += y * 2; // Увеличение шага для форматирования вывода.
			}
			probel /= 2; // Уменьшение значения для форматирования вывода.
		}
		std::cout << '\n'; // Переход на новую строку.
	}

	// Функция extractMin() для извлечения минимального элемента из кучи.
	void* Heap::extractMin()
	{
		void* rc = nullptr; // Инициализация возвращаемого значения.
		if (!isEmpty()) // Проверка на пустоту кучи.
		{
			int minIndex = 0; // Индекс минимального элемента, начинаем с 0.
			// Поиск минимального элемента среди дочерних элементов.
			for (int i = 1; i < size; ++i) {
				if (isLess(storage[i], storage[minIndex])) {
					minIndex = i; // Обновление индекса минимального элемента, если найден более маленький.
				}
			}

			rc = storage[minIndex]; // Сохранение минимального элемента перед удалением.

			storage[minIndex] = storage[size - 1]; // Замена минимального элемента последним элементом в куче.

			size--; // Уменьшение размера кучи.
			heapify(minIndex); // Поддержание свойства кучи после удаления минимального элемента.
		}
		return rc; // Возвращение извлеченного минимального элемента.
	}

	// Функция extractI() для удаления элемента по заданному индексу из кучи.
	void Heap::extractI(int i)
	{
		if (i < 0 || i >= size) // Проверка на корректность индекса.
		{
			std::cerr << "Index out of bounds." << std::endl; // Вывод сообщения об ошибке.
			return; // Возврат из функции.
		}

		// Обмен элемента, который нужно удалить, с последним элементом, а затем поддержание свойства кучи.
		swap(i, size - 1);
		size--; // Уменьшение размера кучи.
		heapify(i); // Поддержание свойства кучи.
	}

	// Функция unionHeap() для объединения двух куч.
	void Heap::unionHeap(Heap& h2)
	{
		for (int i = 0; i < h2.size; ++i) // Перебор элементов второй кучи.
		{
			insert(h2.storage[i]); // Вставка элементов второй кучи в текущую кучу.
		}
		h2.size = 0; // Очистка второй кучи после объединения.
	}
};